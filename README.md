# CRC
CRC16常见的标准有以下几种，被用在各个规范中，其算法原理基本一致，就是在数据的输入和输出有所差异，下边把这些标准的差异列出，并给出C语言的算法实现。

CRC16_CCITT：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在前，高位在后，结果与0x0000异或

CRC16_CCITT_FALSE：多项式x16+x12+x5+1（0x1021），初始值0xFFFF，低位在后，高位在前，结果与0x0000异或

CRC16_XMODEM：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在后，高位在前，结果与0x0000异或

CRC16_X25：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在前，高位在后，结果与0xFFFF异或

CRC16_MODBUS：多项式x16+x15+x2+1（0x8005），初始值0xFFFF，低位在前，高位在后，结果与0x0000异或

CRC16_IBM：多项式x16+x15+x2+1（0x8005），初始值0x0000，低位在前，高位在后，结果与0x0000异或

CRC16_MAXIM：多项式x16+x15+x2+1（0x8005），初始值0x0000，低位在前，高位在后，结果与0xFFFF异或

CRC16_USB：多项式x16+x15+x2+1（0x8005），初始值0xFFFF，低位在前，高位在后，结果与0xFFFF异或


模式     | 多项式  |初始值|数据位序|结果处理
-------- | -----|----|----|----
CRC16_CCITT|x16+x12+x5+1（0x1021）|0x0000|低位在前，高位在后|与0x0000异或
CRC16_CCITT_FALSE|x16+x12+x5+1（0x1021）|0xFFFF|低位在后，高位在前|与0x0000异或
CRC16_XMODEM|x16+x12+x5+1（0x1021）|0x0000|低位在后，高位在前|与0x0000异或
CRC16_X25|x16+x12+x5+1（0x1021）|0x0000|低位在后，高位在前|与0xFFFF异或
CRC16_MODBUS|x16+x15+x2+1（0x8005）|0xFFFF|低位在前，高位在后|与0x0000异或
CRC16_IBM|x16+x15+x2+1（0x8005）|0x0000|低位在前，高位在后|与0x0000异或
CRC16_MAXIM|x16+x15+x2+1（0x8005）|0x0000|低位在前，高位在后|与0xFFFF异或
CRC16_USB|x16+x15+x2+1（0x8005）|0xFFFF|低位在前，高位在后|与0xFFFF异或

多项式产生：
如x16+x12+x5+1
x16表示第16位为1，x5表示第5位为1
(1 << 16) | (1 << 12) | (1 << 5) | (1) = 0x11021
但是CRC16只取低16位，写成16进制数就是 0x1021

CRC16的算法原理：

1.根据CRC16的标准选择初值CRCIn的值。

2.将数据的第一个字节与CRCIn高8位异或。

3.判断最高位，若该位为 0 左移一位，若为 1 左移一位再与多项式Hex码异或。

4.重复3直至8位全部移位计算结束。

5.重复将所有输入数据操作完成以上步骤，所得16位数即16位CRC校验码。

